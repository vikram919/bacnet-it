<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WSSConnectionServerHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bacnet-it</a> &gt; <a href="index.source.html" class="el_package">ch.fhnw.bacnetit.transportbinding.ws.incoming.tls</a> &gt; <span class="el_source">WSSConnectionServerHandler.java</span></div><h1>WSSConnectionServerHandler.java</h1><pre class="source lang-java linenums">package ch.fhnw.bacnetit.transportbinding.ws.incoming.tls;

import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Set;

import ch.fhnw.bacnetit.ase.application.configuration.api.HttpAuthConfig;
import ch.fhnw.bacnetit.ase.application.configuration.api.KeystoreConfig;
import ch.fhnw.bacnetit.ase.application.configuration.api.TruststoreConfig;
import ch.fhnw.bacnetit.ase.application.transaction.ChannelEvent;
import ch.fhnw.bacnetit.ase.encoding.ControlMessageInitEvent;
import ch.fhnw.bacnetit.ase.encoding.api.TPDU;
import ch.fhnw.bacnetit.ase.network.directory.api.DirectoryService;
import ch.fhnw.bacnetit.transportbinding.auth.http.HttpBasicAuthHandler;
import ch.fhnw.bacnetit.transportbinding.ws.ConnectionClient;
import ch.fhnw.bacnetit.transportbinding.ws.ControlMessageHandler;
import ch.fhnw.bacnetit.transportbinding.ws.WSEncoder;
import ch.fhnw.bacnetit.transportbinding.ws.outgoing.tls.WSSConnection;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
import io.netty.util.CharsetUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

/**
 * Handles handshakes and messages
 */
public class WSSConnectionServerHandler
        extends SimpleChannelInboundHandler&lt;Object&gt; {
<span class="nc" id="L50">    private static final InternalLogger LOG = InternalLoggerFactory</span>
<span class="nc" id="L51">            .getInstance(WSSConnectionServerHandler.class);</span>
    private static final String WEBSOCKET_PATH = &quot;/websocket&quot;;
    private static WebSocketServerHandshaker handshaker;
<span class="nc" id="L54">    private String secProtocol = null;</span>
<span class="nc" id="L55">    private HttpAuthConfig httpAuthConfig = null;</span>
    private final KeystoreConfig keystoreConfig;
    private final TruststoreConfig truststoreConfig;

    public WSSConnectionServerHandler(final KeystoreConfig keystoreConfig,
<span class="nc" id="L60">            final TruststoreConfig truststoreConfig) {</span>
<span class="nc" id="L61">        this.keystoreConfig = keystoreConfig;</span>
<span class="nc" id="L62">        this.truststoreConfig = truststoreConfig;</span>
<span class="nc" id="L63">    }</span>

    public void setHttpAuthConfig(final HttpAuthConfig config) {
<span class="nc" id="L66">        this.httpAuthConfig = config;</span>
<span class="nc" id="L67">    }</span>

    public void setSecProtocol(final String secProtocol) {
<span class="nc" id="L70">        this.secProtocol = secProtocol;</span>
<span class="nc" id="L71">    }</span>

    @Override
    public void channelRead0(final ChannelHandlerContext ctx, final Object msg)
            throws Exception {
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (msg instanceof FullHttpRequest) {</span>
<span class="nc" id="L77">            handleHttpRequest(ctx, (FullHttpRequest) msg);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        } else if (msg instanceof WebSocketFrame) {</span>
<span class="nc" id="L79">            handleWebSocketFrame(ctx, (WebSocketFrame) msg);</span>
        }
<span class="nc" id="L81">    }</span>

    @Override
    public void channelReadComplete(final ChannelHandlerContext ctx) {
<span class="nc" id="L85">        ctx.flush();</span>
<span class="nc" id="L86">    }</span>

    // Receive HTTP Request
    private void handleHttpRequest(final ChannelHandlerContext ctx,
            final FullHttpRequest req) {
<span class="nc" id="L91">        LOG.debug(&quot;Received HTTP request &quot; + req);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (req.headers().contains(&quot;Upgrade&quot;)) {</span>
<span class="nc" id="L93">            establishWebSocketConnection(ctx, req);</span>
        }
<span class="nc" id="L95">    }</span>

    private void establishWebSocketConnection(final ChannelHandlerContext ctx,
            final FullHttpRequest req) {

        // When stack.httpauth is true, the HttpBasicAuthHandler must handle the
        // Basic Auth Request
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (httpAuthConfig != null) {</span>
            final Set&lt;String&gt; httpBasicAuthSessions = HttpBasicAuthHandler
<span class="nc" id="L104">                    .getHttpBasicAuthSessions();</span>
<span class="nc" id="L105">            LOG.info(&quot;Amount entries in session space &quot;</span>
<span class="nc" id="L106">                    + httpBasicAuthSessions.size());</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (req.headers().get(&quot;Cookie&quot;) == null) {</span>
<span class="nc" id="L108">                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(</span>
                        HttpVersion.HTTP_1_1, HttpResponseStatus.FORBIDDEN));
<span class="nc" id="L110">                LOG.error(</span>
                        &quot;stack.httpauth is on. Faild to establish connection without cookie&quot;);
<span class="nc" id="L112">                return;</span>
            }

            // Trim the cookie
<span class="nc" id="L116">            final String receivedCookie = Arrays</span>
<span class="nc" id="L117">                    .asList(req.headers().get(&quot;Cookie&quot;).trim().split(&quot;;&quot;))</span>
<span class="nc" id="L118">                    .stream().filter(s -&gt; s.toLowerCase().contains(&quot;sid=&quot;))</span>
<span class="nc" id="L119">                    .findFirst().get().trim();</span>
<span class="nc" id="L120">            LOG.info(&quot;trimmed cookie: &quot; + receivedCookie);</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (!httpBasicAuthSessions.contains(receivedCookie)) {</span>
<span class="nc" id="L123">                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(</span>
                        HttpVersion.HTTP_1_1, HttpResponseStatus.FORBIDDEN));
<span class="nc" id="L125">                LOG.error(</span>
                        &quot;stack.httpauth is on. Faild to establish connection without valid login&quot;);
<span class="nc" id="L127">                return;</span>
            } else {
<span class="nc" id="L129">                LOG.info(</span>
                        &quot;stack.httpauth is on. Establish connection with valid login&quot;);
            }

        }

        // WebSocketHandshake
<span class="nc" id="L136">        final WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(</span>
<span class="nc" id="L137">                getWebSocketLocation(req), secProtocol, true);</span>
<span class="nc" id="L138">        handshaker = wsFactory.newHandshaker(req);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (handshaker == null) {</span>
<span class="nc" id="L140">            WebSocketServerHandshakerFactory</span>
<span class="nc" id="L141">                    .sendUnsupportedVersionResponse(ctx.channel());</span>
        } else {
<span class="nc" id="L143">            final ChannelFuture cf = handshaker.handshake(ctx.channel(), req);</span>
<span class="nc" id="L144">            cf.addListener(new ChannelFutureListener() {</span>
                // Serverside pipeline changes after WebSocket Upgrade
                @Override
                public void operationComplete(final ChannelFuture future)
                        throws Exception {

<span class="nc" id="L150">                    LOG.debug(</span>
                            &quot;WebSocket Server Handshake completed successfully&quot;);
                    // Adding the ControlMessageHandler
<span class="nc" id="L153">                    ctx.pipeline().addBefore(</span>
<span class="nc" id="L154">                            WSSConnectionServerHandler.class.getSimpleName(),</span>
<span class="nc" id="L155">                            ControlMessageHandler.class.getSimpleName(),</span>
                            new ControlMessageHandler());
<span class="nc" id="L157">                    ctx.pipeline().addAfter(</span>
<span class="nc" id="L158">                            WSSConnectionServerHandler.class.getSimpleName(),</span>
<span class="nc" id="L159">                            WSEncoder.class.getSimpleName(), new WSEncoder());</span>
<span class="nc" id="L160">                    ctx.pipeline().fireUserEventTriggered(</span>
                            new ControlMessageInitEvent());

<span class="nc" id="L163">                }</span>
            });
        }
<span class="nc" id="L166">    }</span>

    private void handleWebSocketFrame(final ChannelHandlerContext ctx,
            final WebSocketFrame frame) throws Exception {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (frame instanceof CloseWebSocketFrame) {</span>
<span class="nc" id="L171">            handshaker.close(ctx.channel(),</span>
<span class="nc" id="L172">                    (CloseWebSocketFrame) frame.retain());</span>
<span class="nc" id="L173">            return;</span>
        }
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (frame instanceof PingWebSocketFrame) {</span>
<span class="nc" id="L176">            ctx.channel()</span>
<span class="nc" id="L177">                    .write(new PongWebSocketFrame(frame.content().retain()));</span>
<span class="nc" id="L178">            return;</span>
        }
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (!(frame instanceof BinaryWebSocketFrame)) {</span>
<span class="nc" id="L181">            throw new UnsupportedOperationException(</span>
<span class="nc" id="L182">                    String.format(&quot;%s frame types not supported&quot;,</span>
<span class="nc" id="L183">                            frame.getClass().getName()));</span>
        }
<span class="nc" id="L185">        final ByteBuf buffer = frame.content();</span>
<span class="nc" id="L186">        buffer.skipBytes(2);</span>
<span class="nc" id="L187">        final byte[] bytes = new byte[buffer.readableBytes()];</span>

        // move removing upside
<span class="nc" id="L190">        buffer.readBytes(bytes);</span>

        // Translate here to BACnetMessage
<span class="nc" id="L193">        final TPDU bmsg = new TPDU(bytes);</span>
<span class="nc" id="L194">        LOG.debug(&quot;Successfully decoded new BACnetMessage: &quot; + bmsg);</span>

        // Fire event up to endpoint handler to signal a client connection
<span class="nc" id="L197">        final InetSocketAddress address = (InetSocketAddress) ctx.channel()</span>
<span class="nc" id="L198">                .remoteAddress();</span>

<span class="nc" id="L200">        final ConnectionClient connection = new WSSConnection(address, null,</span>
                keystoreConfig, truststoreConfig);
<span class="nc" id="L202">        connection.setChannel(ctx.channel());</span>
<span class="nc" id="L203">        ctx.pipeline().fireUserEventTriggered(connection);</span>
<span class="nc" id="L204">        LOG.debug(&quot;Register a incoming WebSocketFrame in the local dns&quot;);</span>
        try {
<span class="nc" id="L206">            LOG.debug(String.format(&quot;SourceEID %s, URI: URI: %S&quot;,</span>
<span class="nc" id="L207">                    bmsg.getSourceEID(),</span>
<span class="nc" id="L208">                    new URI(&quot;wss:/&quot; + ctx.channel().remoteAddress())));</span>
<span class="nc" id="L209">        } catch (final URISyntaxException e1) {</span>
            // TODO Auto-generated catch block
<span class="nc" id="L211">            e1.printStackTrace();</span>
<span class="nc" id="L212">        }</span>
//        try {
//            DirectoryService.getInstance().register(bmsg.getSourceEID(),
//                    new URI(&quot;wss:/&quot; + ctx.channel().remoteAddress()), false,
//                    true);
//        } catch (final URISyntaxException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }

        // Put message back into the pipeline
<span class="nc" id="L223">        ctx.fireChannelRead(bmsg);</span>
<span class="nc" id="L224">    }</span>

    private static void sendHttpResponse(final ChannelHandlerContext ctx,
            final FullHttpRequest req, final FullHttpResponse res) {
        // Generate an error page if response getStatus code is not OK (200).
        // if (res.getStatus().code() != 200) {
<span class="nc" id="L230">        final ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(),</span>
                CharsetUtil.UTF_8);
<span class="nc" id="L232">        res.content().writeBytes(buf);</span>
<span class="nc" id="L233">        buf.release();</span>
<span class="nc" id="L234">        HttpUtil.setContentLength(res, res.content().readableBytes());</span>
        // }

        // Send the response and close the connection if necessary.
<span class="nc" id="L238">        final ChannelFuture f = ctx.channel().writeAndFlush(res);</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">        if (!HttpUtil.isKeepAlive(req) || res.status().code() != 200) {</span>
<span class="nc" id="L240">            f.addListener(ChannelFutureListener.CLOSE);</span>
        }
<span class="nc" id="L242">    }</span>

    @Override
    public void exceptionCaught(final ChannelHandlerContext ctx,
            final Throwable cause) {
        Throwable _cause;
<span class="nc bnc" id="L248" title="All 4 branches missed.">        if (cause.getCause() instanceof javax.net.ssl.SSLHandshakeException</span>
                || cause instanceof javax.net.ssl.SSLHandshakeException) {
<span class="nc" id="L250">            _cause = new Exception(cause.getMessage());</span>
        } else {
<span class="nc" id="L252">            _cause = cause;</span>
        }
<span class="nc" id="L254">        ctx.fireExceptionCaught(_cause);</span>
<span class="nc" id="L255">        ctx.close();</span>
<span class="nc" id="L256">    }</span>

    @Override
    public void channelUnregistered(final ChannelHandlerContext ctx)
            throws Exception {
<span class="nc" id="L261">        LOG.debug(&quot;UnregisterEvent reveived from &quot;</span>
<span class="nc" id="L262">                + ctx.channel().remoteAddress());</span>
<span class="nc" id="L263">        final ChannelEvent event = ChannelEvent.REMOVE_CONNECTION_EVENT;</span>
<span class="nc" id="L264">        event.setMsg(ctx.channel().remoteAddress());</span>
<span class="nc" id="L265">        ctx.fireUserEventTriggered(event);</span>
<span class="nc" id="L266">    }</span>

    private String getWebSocketLocation(final FullHttpRequest req) {
<span class="nc" id="L269">        final String location = req.headers().get(HttpHeaderNames.HOST)</span>
                + WEBSOCKET_PATH;
<span class="nc" id="L271">        return &quot;wss://&quot; + location;</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>