<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WSConnectionServerHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bacnet-it</a> &gt; <a href="index.source.html" class="el_package">ch.fhnw.bacnetit.transportbinding.ws.incoming</a> &gt; <span class="el_source">WSConnectionServerHandler.java</span></div><h1>WSConnectionServerHandler.java</h1><pre class="source lang-java linenums">package ch.fhnw.bacnetit.transportbinding.ws.incoming;

import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Set;

import ch.fhnw.bacnetit.ase.application.configuration.api.HttpAuthConfig;
import ch.fhnw.bacnetit.ase.application.transaction.ChannelEvent;
import ch.fhnw.bacnetit.ase.encoding.ControlMessageInitEvent;
import ch.fhnw.bacnetit.ase.encoding.api.TPDU;
import ch.fhnw.bacnetit.ase.network.directory.api.DirectoryService;
import ch.fhnw.bacnetit.transportbinding.auth.http.HttpBasicAuthHandler;
import ch.fhnw.bacnetit.transportbinding.ws.ConnectionClient;
import ch.fhnw.bacnetit.transportbinding.ws.ControlMessageHandler;
import ch.fhnw.bacnetit.transportbinding.ws.WSEncoder;
import ch.fhnw.bacnetit.transportbinding.ws.outgoing.WSConnection;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
import io.netty.util.CharsetUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

/**
 * Handles handshakes and messages
 */
<span class="fc" id="L46">public class WSConnectionServerHandler</span>
        extends SimpleChannelInboundHandler&lt;Object&gt; {
<span class="fc" id="L48">    private static final InternalLogger LOG = InternalLoggerFactory</span>
<span class="fc" id="L49">            .getInstance(WSConnectionServerHandler.class);</span>
    private static final String WEBSOCKET_PATH = &quot;/websocket&quot;;
    private static WebSocketServerHandshaker handshaker;
<span class="fc" id="L52">    private String secProtocol = null;</span>
<span class="fc" id="L53">    private HttpAuthConfig httpAuthConfig = null;</span>

    public void setHttpAuthConfig(final HttpAuthConfig config) {
<span class="nc" id="L56">        this.httpAuthConfig = config;</span>
<span class="nc" id="L57">    }</span>

    public void setSecProtocol(final String secProtocol) {
<span class="fc" id="L60">        this.secProtocol = secProtocol;</span>
<span class="fc" id="L61">    }</span>

    @Override
    public void channelRead0(final ChannelHandlerContext ctx, final Object msg)
            throws Exception {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (msg instanceof FullHttpRequest) {</span>
<span class="fc" id="L67">            handleHttpRequest(ctx, (FullHttpRequest) msg);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        } else if (msg instanceof WebSocketFrame) {</span>
<span class="fc" id="L69">            handleWebSocketFrame(ctx, (WebSocketFrame) msg);</span>
        }
<span class="fc" id="L71">    }</span>

    @Override
    public void channelReadComplete(final ChannelHandlerContext ctx) {
<span class="fc" id="L75">        ctx.flush();</span>
<span class="fc" id="L76">    }</span>

    // Receive HTTP Request
    private void handleHttpRequest(final ChannelHandlerContext ctx,
            final FullHttpRequest req) {
<span class="fc" id="L81">        LOG.debug(&quot;Received HTTP request &quot; + req);</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (req.headers().contains(&quot;Upgrade&quot;)) {</span>
<span class="fc" id="L83">            establishWebSocketConnection(ctx, req);</span>
        }
<span class="fc" id="L85">    }</span>

    private void establishWebSocketConnection(final ChannelHandlerContext ctx,
            final FullHttpRequest req) {

        // When stack.httpauth is true, the HttpBasicAuthHandler must handle the
        // Basic Auth Request
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (httpAuthConfig != null) {</span>
            final Set&lt;String&gt; httpBasicAuthSessions = HttpBasicAuthHandler
<span class="nc" id="L94">                    .getHttpBasicAuthSessions();</span>
<span class="nc" id="L95">            LOG.info(&quot;Amount entries in session space &quot;</span>
<span class="nc" id="L96">                    + httpBasicAuthSessions.size());</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (req.headers().get(&quot;Cookie&quot;) == null) {</span>
<span class="nc" id="L98">                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(</span>
                        HttpVersion.HTTP_1_1, HttpResponseStatus.FORBIDDEN));
<span class="nc" id="L100">                LOG.error(</span>
                        &quot;stack.httpauth is on. Faild to establish connection without cookie&quot;);
<span class="nc" id="L102">                return;</span>
            }

            // Trim the cookie
<span class="nc" id="L106">            final String receivedCookie = Arrays</span>
<span class="nc" id="L107">                    .asList(req.headers().get(&quot;Cookie&quot;).trim().split(&quot;;&quot;))</span>
<span class="nc" id="L108">                    .stream().filter(s -&gt; s.toLowerCase().contains(&quot;sid=&quot;))</span>
<span class="nc" id="L109">                    .findFirst().get().trim();</span>
<span class="nc" id="L110">            LOG.info(&quot;trimmed cookie: &quot; + receivedCookie);</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (!httpBasicAuthSessions.contains(receivedCookie)) {</span>
<span class="nc" id="L113">                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(</span>
                        HttpVersion.HTTP_1_1, HttpResponseStatus.FORBIDDEN));
<span class="nc" id="L115">                LOG.error(</span>
                        &quot;stack.httpauth is on. Faild to establish connection without valid login&quot;);
<span class="nc" id="L117">                return;</span>
            } else {
<span class="nc" id="L119">                LOG.info(</span>
                        &quot;stack.httpauth is on. Establish connection with valid login&quot;);
            }

        }

        // WebSocketHandshake
<span class="fc" id="L126">        final WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(</span>
<span class="fc" id="L127">                getWebSocketLocation(req), secProtocol, true);</span>
<span class="fc" id="L128">        handshaker = wsFactory.newHandshaker(req);</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (handshaker == null) {</span>
<span class="nc" id="L130">            WebSocketServerHandshakerFactory</span>
<span class="nc" id="L131">                    .sendUnsupportedVersionResponse(ctx.channel());</span>
        } else {
<span class="fc" id="L133">            final ChannelFuture cf = handshaker.handshake(ctx.channel(), req);</span>
<span class="fc" id="L134">            cf.addListener(new ChannelFutureListener() {</span>
                // Serverside pipeline changes after WebSocket Upgrade
                @Override
                public void operationComplete(final ChannelFuture future)
                        throws Exception {

<span class="fc" id="L140">                    LOG.debug(</span>
                            &quot;WebSocket Server Handshake completed successfully&quot;);
                    // Adding the ControlMessageHandler
<span class="fc" id="L143">                    ctx.pipeline().addBefore(</span>
<span class="fc" id="L144">                            WSConnectionServerHandler.class.getSimpleName(),</span>
<span class="fc" id="L145">                            ControlMessageHandler.class.getSimpleName(),</span>
                            new ControlMessageHandler());
<span class="fc" id="L147">                    ctx.pipeline().addAfter(</span>
<span class="fc" id="L148">                            WSConnectionServerHandler.class.getSimpleName(),</span>
<span class="fc" id="L149">                            WSEncoder.class.getSimpleName(), new WSEncoder());</span>
<span class="fc" id="L150">                    ctx.pipeline().fireUserEventTriggered(</span>
                            new ControlMessageInitEvent());

<span class="fc" id="L153">                }</span>
            });
        }
<span class="fc" id="L156">    }</span>

    private void handleWebSocketFrame(final ChannelHandlerContext ctx,
            final WebSocketFrame frame) throws Exception {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (frame instanceof CloseWebSocketFrame) {</span>
<span class="nc" id="L161">            handshaker.close(ctx.channel(),</span>
<span class="nc" id="L162">                    (CloseWebSocketFrame) frame.retain());</span>
<span class="nc" id="L163">            return;</span>
        }
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (frame instanceof PingWebSocketFrame) {</span>
<span class="nc" id="L166">            ctx.channel()</span>
<span class="nc" id="L167">                    .write(new PongWebSocketFrame(frame.content().retain()));</span>
<span class="nc" id="L168">            return;</span>
        }
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (!(frame instanceof BinaryWebSocketFrame)) {</span>
<span class="nc" id="L171">            throw new UnsupportedOperationException(</span>
<span class="nc" id="L172">                    String.format(&quot;%s frame types not supported&quot;,</span>
<span class="nc" id="L173">                            frame.getClass().getName()));</span>
        }
<span class="fc" id="L175">        final ByteBuf buffer = frame.content();</span>
<span class="fc" id="L176">        buffer.skipBytes(2);</span>
<span class="fc" id="L177">        final byte[] bytes = new byte[buffer.readableBytes()];</span>

        // move removing upside
<span class="fc" id="L180">        buffer.readBytes(bytes);</span>

        // Translate here to BACnetMessage
<span class="fc" id="L183">        final TPDU bmsg = new TPDU(bytes);</span>
<span class="fc" id="L184">        LOG.debug(&quot;Successfully decoded new BACnetMessage: &quot; + bmsg);</span>

        // Fire event up to endpoint handler to signal a client connection
<span class="fc" id="L187">        final InetSocketAddress address = (InetSocketAddress) ctx.channel()</span>
<span class="fc" id="L188">                .remoteAddress();</span>

<span class="fc" id="L190">        final ConnectionClient connection = new WSConnection(address, null);</span>
<span class="fc" id="L191">        connection.setChannel(ctx.channel());</span>
<span class="fc" id="L192">        ctx.pipeline().fireUserEventTriggered(connection);</span>
<span class="fc" id="L193">        LOG.debug(&quot;Register a incoming WebSocketFrame in the local dns&quot;);</span>
        try {
<span class="fc" id="L195">            LOG.debug(String.format(&quot;SourceEID %s, URI: URI: %S&quot;,</span>
<span class="fc" id="L196">                    bmsg.getSourceEID(),</span>
<span class="fc" id="L197">                    new URI(&quot;ws:/&quot; + ctx.channel().remoteAddress())));</span>
<span class="nc" id="L198">        } catch (final URISyntaxException e1) {</span>
            // TODO Auto-generated catch block
<span class="nc" id="L200">            e1.printStackTrace();</span>
<span class="fc" id="L201">        }</span>
        try {
<span class="fc" id="L203">            DirectoryService.getInstance().register(bmsg.getSourceEID(),</span>
<span class="fc" id="L204">                    new URI(&quot;ws:/&quot; + ctx.channel().remoteAddress()), false,</span>
                    true);
<span class="nc" id="L206">        } catch (final URISyntaxException e) {</span>
            // TODO Auto-generated catch block
<span class="nc" id="L208">            e.printStackTrace();</span>
<span class="fc" id="L209">        }</span>

        // Put message back into the pipeline
<span class="fc" id="L212">        ctx.fireChannelRead(bmsg);</span>
<span class="fc" id="L213">    }</span>

    private static void sendHttpResponse(final ChannelHandlerContext ctx,
            final FullHttpRequest req, final FullHttpResponse res) {
        // Generate an error page if response getStatus code is not OK (200).
        // if (res.getStatus().code() != 200) {
<span class="nc" id="L219">        final ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(),</span>
                CharsetUtil.UTF_8);
<span class="nc" id="L221">        res.content().writeBytes(buf);</span>
<span class="nc" id="L222">        buf.release();</span>
<span class="nc" id="L223">        HttpUtil.setContentLength(res, res.content().readableBytes());</span>
        // }

        // Send the response and close the connection if necessary.
<span class="nc" id="L227">        final ChannelFuture f = ctx.channel().writeAndFlush(res);</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">        if (!HttpUtil.isKeepAlive(req) || res.status().code() != 200) {</span>
<span class="nc" id="L229">            f.addListener(ChannelFutureListener.CLOSE);</span>
        }
<span class="nc" id="L231">    }</span>

    @Override
    public void exceptionCaught(final ChannelHandlerContext ctx,
            final Throwable cause) {
        Throwable _cause;
<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (cause.getCause() instanceof javax.net.ssl.SSLHandshakeException</span>
                || cause instanceof javax.net.ssl.SSLHandshakeException) {
<span class="nc" id="L239">            _cause = new Exception(cause.getMessage());</span>
        } else {
<span class="nc" id="L241">            _cause = cause;</span>
        }
<span class="nc" id="L243">        ctx.fireExceptionCaught(_cause);</span>
<span class="nc" id="L244">        ctx.close();</span>
<span class="nc" id="L245">    }</span>

    @Override
    public void channelUnregistered(final ChannelHandlerContext ctx)
            throws Exception {
<span class="fc" id="L250">        LOG.debug(&quot;UnregisterEvent reveived from &quot;</span>
<span class="fc" id="L251">                + ctx.channel().remoteAddress());</span>
<span class="fc" id="L252">        final ChannelEvent event = ChannelEvent.REMOVE_CONNECTION_EVENT;</span>
<span class="fc" id="L253">        event.setMsg(ctx.channel().remoteAddress());</span>
<span class="fc" id="L254">        ctx.fireUserEventTriggered(event);</span>
<span class="fc" id="L255">    }</span>

    private String getWebSocketLocation(final FullHttpRequest req) {
<span class="fc" id="L258">        final String location = req.headers().get(HttpHeaderNames.HOST)</span>
                + WEBSOCKET_PATH;
<span class="fc" id="L260">        return &quot;ws://&quot; + location;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>