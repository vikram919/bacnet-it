<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Encodable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bacnet-it</a> &gt; <a href="index.source.html" class="el_package">ch.fhnw.bacnetit.samplesandtests.api.encoding.type</a> &gt; <span class="el_source">Encodable.java</span></div><h1>Encodable.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * ============================================================================
 * GNU General Public License
 * ============================================================================
 *
 * Copyright (C) 2017 University of Applied Sciences and Arts,
 * Northwestern Switzerland FHNW,
 * Institute of Mobile and Distributed Systems.
 * All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.orglicenses.
 *******************************************************************************/
package ch.fhnw.bacnetit.samplesandtests.api.encoding.type;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.Map;

import ch.fhnw.bacnetit.samplesandtests.api.deviceobjects.BACnetObjectFactory;
import ch.fhnw.bacnetit.samplesandtests.api.deviceobjects.BACnetObjectType;
import ch.fhnw.bacnetit.samplesandtests.api.deviceobjects.BACnetProperty;
import ch.fhnw.bacnetit.samplesandtests.api.deviceobjects.BACnetPropertyIdentifier;
import ch.fhnw.bacnetit.samplesandtests.api.deviceobjects.VendorServiceKey;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.base.BACnetUtils;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.exception.BACnetErrorException;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.exception.BACnetException;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.exception.ReflectionException;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.constructed.Choice;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.constructed.Sequence;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.constructed.SequenceOf;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.enumerated.ErrorClass;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.enumerated.ErrorCode;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.eventParameter.EventParameter;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.primitive.Null;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.primitive.Primitive;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.type.primitive.UnsignedInteger;
import ch.fhnw.bacnetit.samplesandtests.api.encoding.util.ByteQueue;

//import com.serotonin.bacnet4j.event.ExceptionDispatch;

<span class="fc" id="L52">abstract public class Encodable implements Serializable {</span>
    private static final long serialVersionUID = -4378016931626697698L;

    abstract public void write(ByteQueue queue);

    abstract public void write(ByteQueue queue, int contextId);

    @Override
    public String toString() {
<span class="nc" id="L61">        return &quot;Encodable(&quot; + getClass().getName() + &quot;)&quot;;</span>
    }

    protected static void popTagData(final ByteQueue queue,
            final TagData tagData) {
<span class="nc" id="L66">        peekTagData(queue, tagData);</span>
<span class="nc" id="L67">        queue.pop(tagData.tagLength);</span>
<span class="nc" id="L68">    }</span>

    protected static void peekTagData(final ByteQueue queue,
            final TagData tagData) {
<span class="nc" id="L72">        int peekIndex = 0;</span>
<span class="nc" id="L73">        final byte b = queue.peek(peekIndex++);</span>
<span class="nc" id="L74">        tagData.tagNumber = (b &amp; 0xff) &gt;&gt; 4;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        tagData.contextSpecific = (b &amp; 8) != 0;</span>
<span class="nc" id="L76">        tagData.length = (b &amp; 7);</span>

<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (tagData.tagNumber == 0xf) {</span>
            // Extended tag.
<span class="nc" id="L80">            tagData.tagNumber = BACnetUtils.toInt(queue.peek(peekIndex++));</span>
        }

<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (tagData.length == 5) {</span>
<span class="nc" id="L84">            tagData.length = BACnetUtils.toInt(queue.peek(peekIndex++));</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (tagData.length == 254) {</span>
<span class="nc" id="L86">                tagData.length = (BACnetUtils</span>
<span class="nc" id="L87">                        .toInt(queue.peek(peekIndex++)) &lt;&lt; 8)</span>
<span class="nc" id="L88">                        | BACnetUtils.toInt(queue.peek(peekIndex++));</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            } else if (tagData.length == 255) {</span>
<span class="nc" id="L90">                tagData.length = (BACnetUtils</span>
<span class="nc" id="L91">                        .toLong(queue.peek(peekIndex++)) &lt;&lt; 24)</span>
<span class="nc" id="L92">                        | (BACnetUtils.toLong(queue.peek(peekIndex++)) &lt;&lt; 16)</span>
<span class="nc" id="L93">                        | (BACnetUtils.toLong(queue.peek(peekIndex++)) &lt;&lt; 8)</span>
<span class="nc" id="L94">                        | BACnetUtils.toLong(queue.peek(peekIndex++));</span>
            }
        }

<span class="nc" id="L98">        tagData.tagLength = peekIndex;</span>
<span class="nc" id="L99">    }</span>

    protected static int peekTagNumber(final ByteQueue queue) {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (queue.size() == 0) {</span>
<span class="nc" id="L103">            return -1;</span>
        }

        // Take a peek at the tag number.
<span class="fc" id="L107">        int tagNumber = (queue.peek(0) &amp; 0xff) &gt;&gt; 4;</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        if (tagNumber == 15) {</span>
<span class="nc" id="L109">            tagNumber = queue.peek(1) &amp; 0xff;</span>
        }
<span class="fc" id="L111">        return tagNumber;</span>
    }

    //
    // Write context tags for base types.
    public void writeContextTag(final ByteQueue queue, final int contextId,
            final boolean start) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (contextId &lt;= 14) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            queue.push((contextId &lt;&lt; 4) | (start ? 0xe : 0xf));</span>
        } else {
<span class="fc bfc" id="L121" title="All 2 branches covered.">            queue.push(start ? 0xfe : 0xff);</span>
<span class="fc" id="L122">            queue.push(contextId);</span>
        }
<span class="fc" id="L124">    }</span>

    //
    // Read start tags.
    protected static int readStart(final ByteQueue queue) {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (queue.size() == 0) {</span>
<span class="nc" id="L130">            return -1;</span>
        }

<span class="nc" id="L133">        final int b = queue.peek(0) &amp; 0xff;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if ((b &amp; 0xf) != 0xe) {</span>
<span class="nc" id="L135">            return -1;</span>
        }
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if ((b &amp; 0xf0) == 0xf0) {</span>
<span class="nc" id="L138">            return queue.peek(1);</span>
        }
<span class="nc" id="L140">        return b &gt;&gt; 4;</span>
    }

    protected static int popStart(final ByteQueue queue) {
<span class="nc" id="L144">        final int contextId = readStart(queue);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (contextId != -1) {</span>
<span class="nc" id="L146">            queue.pop();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (contextId &gt; 14) {</span>
<span class="nc" id="L148">                queue.pop();</span>
            }
        }
<span class="nc" id="L151">        return contextId;</span>
    }

    protected static void popStart(final ByteQueue queue, final int contextId)
            throws BACnetErrorException {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (popStart(queue) != contextId) {</span>
<span class="nc" id="L157">            throw new BACnetErrorException(ErrorClass.property,</span>
                    ErrorCode.missingRequiredParameter);
        }
<span class="nc" id="L160">    }</span>

    //
    // Read end tags.
    protected static int readEnd(final ByteQueue queue) {
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (queue.size() == 0) {</span>
<span class="nc" id="L166">            return -1;</span>
        }
<span class="nc" id="L168">        final int b = queue.peek(0) &amp; 0xff;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if ((b &amp; 0xf) != 0xf) {</span>
<span class="nc" id="L170">            return -1;</span>
        }
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if ((b &amp; 0xf0) == 0xf0) {</span>
<span class="nc" id="L173">            return queue.peek(1);</span>
        }
<span class="nc" id="L175">        return b &gt;&gt; 4;</span>
    }

    protected static void popEnd(final ByteQueue queue, final int contextId)
            throws BACnetErrorException {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (readEnd(queue) != contextId) {</span>
<span class="nc" id="L181">            throw new BACnetErrorException(ErrorClass.property,</span>
                    ErrorCode.missingRequiredParameter);
        }
<span class="nc" id="L184">        queue.pop();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (contextId &gt; 14) {</span>
<span class="nc" id="L186">            queue.pop();</span>
        }
<span class="nc" id="L188">    }</span>

    private static boolean matchContextId(final ByteQueue queue,
            final int contextId) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        return peekTagNumber(queue) == contextId;</span>
    }

    protected static boolean matchStartTag(final ByteQueue queue,
            final int contextId) {
<span class="nc bnc" id="L197" title="All 4 branches missed.">        return matchContextId(queue, contextId) &amp;&amp; (queue.peek(0) &amp; 0xf) == 0xe;</span>
    }

    protected static boolean matchEndTag(final ByteQueue queue,
            final int contextId) {
<span class="nc bnc" id="L202" title="All 4 branches missed.">        return matchContextId(queue, contextId) &amp;&amp; (queue.peek(0) &amp; 0xf) == 0xf;</span>
    }

    protected static boolean matchNonEndTag(final ByteQueue queue,
            final int contextId) {
<span class="pc bpc" id="L207" title="3 of 4 branches missed.">        return matchContextId(queue, contextId) &amp;&amp; (queue.peek(0) &amp; 0xf) != 0xf;</span>
    }

    //
    // Basic read and write. Pretty trivial.
    protected static void write(final ByteQueue queue, final Encodable type) {
<span class="fc" id="L213">        type.write(queue);</span>
<span class="fc" id="L214">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    protected static &lt;T extends Encodable&gt; T read(final ByteQueue queue,
            final Class&lt;T&gt; clazz) throws BACnetException {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (clazz == Primitive.class) {</span>
<span class="nc" id="L220">            return (T) Primitive.createPrimitive(queue);</span>
        }

        try {
<span class="fc" id="L224">            return clazz.getConstructor(new Class[] { ByteQueue.class })</span>
<span class="fc" id="L225">                    .newInstance(new Object[] { queue });</span>
<span class="nc" id="L226">        } catch (final NoSuchMethodException e) {</span>
            // Check if this is an EventParameter
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if (clazz == EventParameter.class) {</span>
<span class="nc" id="L229">                return (T) EventParameter.createEventParameter(queue);</span>
            }
<span class="nc" id="L231">            throw new BACnetException(e);</span>
<span class="nc" id="L232">        } catch (final InvocationTargetException e) {</span>
            // Check if there is a wrapped BACnet exception
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (e.getCause() instanceof BACnetException) {</span>
<span class="nc" id="L235">                throw (BACnetException) e.getCause();</span>
            }
<span class="nc" id="L237">            throw new ReflectionException(e);</span>
<span class="nc" id="L238">        } catch (final Exception e) {</span>
<span class="nc" id="L239">            throw new BACnetException(e);</span>
        }
    }

    //
    // Read and write with context id.
    protected static &lt;T extends Encodable&gt; T read(final ByteQueue queue,
            final Class&lt;T&gt; clazz, final int contextId) throws BACnetException {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (!matchNonEndTag(queue, contextId)) {</span>
<span class="nc" id="L248">            throw new BACnetErrorException(ErrorClass.property,</span>
                    ErrorCode.missingRequiredParameter);
        }

<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (Primitive.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L253">            return read(queue, clazz);</span>
        }
<span class="nc" id="L255">        return readWrapped(queue, clazz, contextId);</span>
    }

    protected static void write(final ByteQueue queue, final Encodable type,
            final int contextId) {
<span class="fc" id="L260">        type.write(queue, contextId);</span>
<span class="fc" id="L261">    }</span>

    //
    // Optional read and write.
    protected static void writeOptional(final ByteQueue queue,
            final Encodable type) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L268">            return;</span>
        }
<span class="nc" id="L270">        write(queue, type);</span>
<span class="nc" id="L271">    }</span>

    protected static void writeOptional(final ByteQueue queue,
            final Encodable type, final int contextId) {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (type == null) {</span>
<span class="fc" id="L276">            return;</span>
        }
<span class="fc" id="L278">        write(queue, type, contextId);</span>
<span class="fc" id="L279">    }</span>

    protected static &lt;T extends Encodable&gt; T readOptional(final ByteQueue queue,
            final Class&lt;T&gt; clazz, final int contextId) throws BACnetException {
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (!matchNonEndTag(queue, contextId)) {</span>
<span class="fc" id="L284">            return null;</span>
        }
<span class="nc" id="L286">        return read(queue, clazz, contextId);</span>
    }

    //
    // Read lists
    protected static &lt;T extends Encodable&gt; SequenceOf&lt;T&gt; readSequenceOf(
            final ByteQueue queue, final Class&lt;T&gt; clazz)
            throws BACnetException {
<span class="nc" id="L294">        return new SequenceOf&lt;T&gt;(queue, clazz);</span>
    }

    protected static &lt;T extends Encodable&gt; SequenceOf&lt;T&gt; readSequenceOf(
            final ByteQueue queue, final int count, final Class&lt;T&gt; clazz)
            throws BACnetException {
<span class="nc" id="L300">        return new SequenceOf&lt;T&gt;(queue, count, clazz);</span>
    }

    protected static &lt;T extends Encodable&gt; SequenceOf&lt;T&gt; readSequenceOf(
            final ByteQueue queue, final Class&lt;T&gt; clazz, final int contextId)
            throws BACnetException {
<span class="nc" id="L306">        popStart(queue, contextId);</span>
<span class="nc" id="L307">        final SequenceOf&lt;T&gt; result = new SequenceOf&lt;T&gt;(queue, clazz, contextId);</span>
<span class="nc" id="L308">        popEnd(queue, contextId);</span>
<span class="nc" id="L309">        return result;</span>
    }

    protected static &lt;T extends Encodable&gt; T readSequenceType(
            final ByteQueue queue, final Class&lt;T&gt; clazz, final int contextId)
            throws BACnetException {
<span class="nc" id="L315">        popStart(queue, contextId);</span>
        T result;
        try {
<span class="nc" id="L318">            result = clazz</span>
<span class="nc" id="L319">                    .getConstructor(</span>
                            new Class[] { ByteQueue.class, Integer.TYPE })
<span class="nc" id="L321">                    .newInstance(new Object[] { queue, contextId });</span>
<span class="nc" id="L322">        } catch (final Exception e) {</span>
<span class="nc" id="L323">            throw new BACnetException(e);</span>
<span class="nc" id="L324">        }</span>
<span class="nc" id="L325">        popEnd(queue, contextId);</span>
<span class="nc" id="L326">        return result;</span>
    }

    protected static SequenceOf&lt;Choice&gt; readSequenceOfChoice(
            final ByteQueue queue,
            final List&lt;Class&lt;? extends Encodable&gt;&gt; classes, final int contextId)
            throws BACnetException {
<span class="nc" id="L333">        popStart(queue, contextId);</span>
<span class="nc" id="L334">        final SequenceOf&lt;Choice&gt; result = new SequenceOf&lt;Choice&gt;();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        while (readEnd(queue) != contextId) {</span>
<span class="nc" id="L336">            result.add(new Choice(queue, classes));</span>
        }
<span class="nc" id="L338">        popEnd(queue, contextId);</span>
<span class="nc" id="L339">        return result;</span>
    }

    protected static &lt;T extends Encodable&gt; SequenceOf&lt;T&gt; readOptionalSequenceOf(
            final ByteQueue queue, final Class&lt;T&gt; clazz, final int contextId)
            throws BACnetException {
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (readStart(queue) != contextId) {</span>
<span class="nc" id="L346">            return null;</span>
        }
<span class="nc" id="L348">        return readSequenceOf(queue, clazz, contextId);</span>
    }

    // Read and write encodable
    protected static void writeEncodable(final ByteQueue queue,
            final Encodable type, final int contextId) {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (Primitive.class.isAssignableFrom(type.getClass())) {</span>
<span class="fc" id="L355">            ((Primitive) type).writeEncodable(queue, contextId);</span>
        } else {
<span class="nc" id="L357">            type.write(queue, contextId);</span>
        }
<span class="fc" id="L359">    }</span>

    protected static Encodable readEncodable(final ByteQueue queue,
            final BACnetObjectType objectType,
            final BACnetPropertyIdentifier propertyIdentifier,
            final UnsignedInteger propertyArrayIndex, final int contextId)
            throws BACnetException {
        // A property array index of 0 indicates a request for the length of an
        // array.
<span class="nc bnc" id="L368" title="All 4 branches missed.">        if (propertyArrayIndex != null &amp;&amp; propertyArrayIndex.intValue() == 0) {</span>
<span class="nc" id="L369">            return readWrapped(queue, UnsignedInteger.class, contextId);</span>
        }

<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (!matchNonEndTag(queue, contextId)) {</span>
<span class="nc" id="L373">            throw new BACnetErrorException(ErrorClass.property,</span>
                    ErrorCode.missingRequiredParameter);
        }

<span class="nc" id="L377">        final BACnetProperty def = BACnetObjectFactory</span>
<span class="nc" id="L378">                .getPropertyTypeDefinition(objectType, propertyIdentifier);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (def == null) {</span>
<span class="nc" id="L380">            return new AmbiguousValue(queue, contextId);</span>
        }

<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (BACnetObjectFactory.isCommandable(objectType, propertyIdentifier)) {</span>
            // If the object is commandable, it could be set to Null, so we need
            // to treat it as ambiguous.
<span class="nc" id="L386">            final AmbiguousValue amb = new AmbiguousValue(queue, contextId);</span>

<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (amb.isNull()) {</span>
<span class="nc" id="L389">                return new Null();</span>
            }

            // Try converting to the definition value.
<span class="nc" id="L393">            return amb.convertTo(def.getClazz());</span>
        }

<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (propertyArrayIndex != null) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (!def.isSequence()</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                    &amp;&amp; !SequenceOf.class.isAssignableFrom(def.getClazz())) {</span>
<span class="nc" id="L399">                throw new BACnetErrorException(ErrorClass.property,</span>
                        ErrorCode.propertyIsNotAList);
            }
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (SequenceOf.class.isAssignableFrom(def.getClazz())) {</span>
<span class="nc" id="L403">                return readWrapped(queue, def.getInnerType(), contextId);</span>
            }
        } else {
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (def.isSequence()) {</span>
<span class="nc" id="L407">                return readSequenceOf(queue, def.getClazz(), contextId);</span>
            }
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (SequenceOf.class.isAssignableFrom(def.getClazz())) {</span>
<span class="nc" id="L410">                return readSequenceType(queue, def.getClazz(), contextId);</span>
            }
        }

<span class="nc" id="L414">        return readWrapped(queue, def.getClazz(), contextId);</span>
    }

    protected static Encodable readOptionalEncodable(final ByteQueue queue,
            final BACnetObjectType objectType,
            final BACnetPropertyIdentifier propertyIdentifier,
            final int contextId) throws BACnetException {
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (readStart(queue) != contextId) {</span>
<span class="nc" id="L422">            return null;</span>
        }
<span class="nc" id="L424">        return readEncodable(queue, objectType, propertyIdentifier, null,</span>
                contextId);
    }

    protected static SequenceOf&lt;? extends Encodable&gt; readSequenceOfEncodable(
            final ByteQueue queue, final BACnetObjectType objectType,
            final BACnetPropertyIdentifier propertyIdentifier,
            final int contextId) throws BACnetException {
<span class="nc" id="L432">        final BACnetProperty def = BACnetObjectFactory</span>
<span class="nc" id="L433">                .getPropertyTypeDefinition(objectType, propertyIdentifier);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (def == null) {</span>
<span class="nc" id="L435">            return readSequenceOf(queue, AmbiguousValue.class, contextId);</span>
        }
<span class="nc" id="L437">        return readSequenceOf(queue, def.getClazz(), contextId);</span>
    }

    // Read vendor-specific
    protected static Sequence readVendorSpecific(final ByteQueue queue,
            final UnsignedInteger vendorId, final UnsignedInteger serviceNumber,
            final Map&lt;VendorServiceKey, SequenceDefinition&gt; resolutions,
            final int contextId) throws BACnetException {
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if (readStart(queue) != contextId) {</span>
<span class="nc" id="L446">            return null;</span>
        }

<span class="nc" id="L449">        final VendorServiceKey key = new VendorServiceKey(vendorId,</span>
                serviceNumber);
<span class="nc" id="L451">        final SequenceDefinition def = resolutions.get(key);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (def == null) {</span>
            // ExceptionDispatch.fireUnimplementedVendorService(vendorId,
            // serviceNumber, queue);
<span class="nc" id="L455">            return null;</span>
        }

<span class="nc" id="L458">        return new Sequence(def, queue, contextId);</span>
    }

    private static &lt;T extends Encodable&gt; T readWrapped(final ByteQueue queue,
            final Class&lt;T&gt; clazz, final int contextId) throws BACnetException {
<span class="nc" id="L463">        popStart(queue, contextId);</span>
<span class="nc" id="L464">        final T result = read(queue, clazz);</span>
<span class="nc" id="L465">        popEnd(queue, contextId);</span>
<span class="nc" id="L466">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>