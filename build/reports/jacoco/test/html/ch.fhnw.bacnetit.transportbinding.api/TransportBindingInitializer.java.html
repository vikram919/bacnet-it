<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransportBindingInitializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bacnet-it</a> &gt; <a href="index.source.html" class="el_package">ch.fhnw.bacnetit.transportbinding.api</a> &gt; <span class="el_source">TransportBindingInitializer.java</span></div><h1>TransportBindingInitializer.java</h1><pre class="source lang-java linenums">package ch.fhnw.bacnetit.transportbinding.api;

import java.net.InetSocketAddress;
import java.net.URI;
import java.util.List;

import ch.fhnw.bacnetit.ase.application.service.api.TransportBindingService;
import ch.fhnw.bacnetit.ase.application.transaction.ChannelEvent;
import ch.fhnw.bacnetit.ase.encoding.ControlMessage;
import ch.fhnw.bacnetit.ase.encoding.ControlMessageInitEvent;
import ch.fhnw.bacnetit.ase.encoding.ControlMessageReceivedEvent;
import ch.fhnw.bacnetit.ase.encoding.UnsignedInteger31;
import ch.fhnw.bacnetit.ase.encoding.api.BACnetEID;
import ch.fhnw.bacnetit.ase.encoding.api.TPDU;
import ch.fhnw.bacnetit.ase.encoding.api.T_UnitDataRequest;
import ch.fhnw.bacnetit.ase.transportbinding.service.api.ASEService;
import ch.fhnw.bacnetit.transportbinding.IncomingConnectionHandler;
import ch.fhnw.bacnetit.transportbinding.OutgoingConnectionHandler;
import ch.fhnw.bacnetit.transportbinding.ws.ConnectionClient;
import ch.fhnw.bacnetit.transportbinding.ws.EndPointHandler;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.timeout.WriteTimeoutException;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

@Sharable
<span class="fc" id="L31">public class TransportBindingInitializer extends ChannelDuplexHandler</span>
        implements EndPointHandler, ASEService, BindingConfiguration {

<span class="fc" id="L34">    private static final InternalLogger LOG = InternalLoggerFactory</span>
<span class="fc" id="L35">            .getInstance(TransportBindingInitializer.class);</span>
    private OutgoingConnectionHandler outgoingConnectionHandler;
    private IncomingConnectionHandler incomingConnectionHandler;
    private TransportBindingService transportBindingService;

    @Override
    public void userEventTriggered(final ChannelHandlerContext ctx,
            final Object evt) {
        try {
            // Event ControlMessageReceivedEvent: Do register the received (by
            // ControlMessage)
            // BacnetEids
<span class="fc" id="L47">            LOG.debug(&quot;Host received &quot; + evt);</span>

<span class="fc bfc" id="L49" title="All 2 branches covered.">            if (evt instanceof ControlMessageReceivedEvent) {</span>
<span class="fc" id="L50">                LOG.debug(&quot;Got a ControlMessageReceivedEvent&quot;);</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">                for (final UnsignedInteger31 ui : ((ControlMessageReceivedEvent) evt)</span>
<span class="fc" id="L52">                        .getControlMessage().getBacnetEidList()) {</span>
                    // in case localhost is written as
                    // &quot;localhost/127.0.0.1:8080&quot;
<span class="fc" id="L55">                    final String[] uri = ctx.channel().remoteAddress()</span>
<span class="fc" id="L56">                            .toString().split(&quot;/&quot;);</span>

                    // control message protocol is always websocket
<span class="fc" id="L59">                    final URI remoteUri = new URI(</span>
                            &quot;ws://&quot; + uri[uri.length - 1]);

<span class="fc" id="L62">                    this.transportBindingService</span>
<span class="fc" id="L63">                            .onRemoteAdded(new BACnetEID(ui), remoteUri);</span>
<span class="fc" id="L64">                    LOG.debug(</span>
                            &quot;Pass received control message to BACnetEntityHandler&quot;);

<span class="fc" id="L67">                }</span>
            }
            // Event ControlMessageInitEvent: Prepare and send a ControlMessage
            // containing the ChannelListeners
<span class="fc bfc" id="L71" title="All 2 branches covered.">            else if (evt instanceof ControlMessageInitEvent) {</span>
<span class="fc" id="L72">                LOG.debug(&quot;Got a ControlMessageInitEvent&quot;);</span>
                // Create ControlMessage

<span class="fc" id="L75">                final byte controlMessageType = ControlMessage.ADDREMOTE;</span>
<span class="fc" id="L76">                final List&lt;UnsignedInteger31&gt; bacneteids = this.transportBindingService</span>
<span class="fc" id="L77">                        .getChannelListeners();</span>
                // TODO Read out group controller ids
<span class="fc" id="L79">                final List&lt;UnsignedInteger31&gt; groupIds = null;</span>

                // Create a control message
<span class="fc" id="L82">                final ControlMessage cm = new ControlMessage(controlMessageType,</span>
                        bacneteids, groupIds);

<span class="fc" id="L85">                ctx.writeAndFlush(cm);</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">            } else if (evt instanceof WriteTimeoutException) {</span>
<span class="nc" id="L87">                System.out.println(&quot;WriteTimeoutException&quot;);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            } else if (evt instanceof TPDU) {</span>
                /*
                 * Handle the bacnet message.
                 *
                 * TPDU msg = (TPDU) evt; if (msg.getService() instanceof
                 * ConfirmedRequestService) {
                 * LOG.debug(&quot;trigger received for ConfirmedRequestService: &quot; +
                 * msg.getService()); } else if (msg.getService() instanceof
                 * UnconfirmedRequestService) {
                 * LOG.debug(&quot;trigger received for UnconfirmedRequestService: &quot;
                 * + msg.getService()); } else if (msg.getService() instanceof
                 * AcknowledgementService) {
                 * LOG.debug(&quot;trigger received for AcknowledgementService: &quot; +
                 * msg.getService()); } else if (msg.getBody().length &gt; 0) {
                 * LOG.debug(&quot;trigger received for Response&quot;); }
                 */
<span class="fc bfc" id="L104" title="All 2 branches covered.">            } else if (evt instanceof ConnectionClient) {</span>
                /*
                 * Request received from the transport binding layer. Check if
                 * the connection must be cached, what is needed if a stateful
                 * protocol like websocket is in use. Update DirectoryService if
                 * necessary.
                 */
<span class="fc" id="L111">                final ConnectionClient connection = (ConnectionClient) evt;</span>
<span class="fc" id="L112">                final InetSocketAddress remoteAddress = (InetSocketAddress) ctx</span>
<span class="fc" id="L113">                        .channel().remoteAddress();</span>
<span class="fc" id="L114">                LOG.debug(&quot;(evt instanceof ConnectionClient) &quot;);</span>
<span class="fc" id="L115">                LOG.debug(remoteAddress.toString());</span>

                /*
                 * Create or update the connection which contains a channel to
                 * the initiating remote partner and which can be used in future
                 * as communication channel. We are acting as server!
                 */

<span class="fc" id="L123">                outgoingConnectionHandler.updateConnectionCache(remoteAddress,</span>
                        connection);
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">            } else if (evt.equals(ChannelEvent.CLOSE_CHANNEL_EVENT)) {</span>
                /*
                 * Close the channel which is not needed any longer.
                 */
<span class="nc" id="L129">                ctx.channel().close();</span>
<span class="nc" id="L130">                LOG.debug(&quot;trigger CLOSE_CHANNEL_EVENT received&quot;);</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            } else if (evt.equals(</span>
                    ChannelEvent.CLOSE_CHANNEL_EVENT_ONLY_ON_UNCONFIRMED_REQUEST)) {
                /*
                 * Close the channel but only if the service request was a
                 * unconfirmed request.
                 */
<span class="nc" id="L137">                final ChannelEvent event = (ChannelEvent) evt;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                if (event.getMsg() instanceof TPDU) {</span>
<span class="nc" id="L139">                    final TPDU msg = (TPDU) event.getMsg();</span>
                    // if (msg.getService() instanceof
                    // UnconfirmedRequestService) {
<span class="nc bnc" id="L142" title="All 2 branches missed.">                    if (!msg.isConfirmedRequest()) {</span>
<span class="nc" id="L143">                        ctx.channel().close();</span>
<span class="nc" id="L144">                        LOG.debug(</span>
                                &quot;trigger CLOSE_CHANNEL_EVENT_ONLY_ON_UNCONFIRMED_REQUEST received&quot;);
                    }
                }
<span class="pc bfc" id="L148" title="All 2 branches covered.">            } else if (evt.equals(ChannelEvent.REMOVE_CONNECTION_EVENT)) {</span>
<span class="fc" id="L149">                LOG.debug(&quot;trigger REMOVE_CONNECTION_EVENT received&quot;);</span>
<span class="fc" id="L150">                final ChannelEvent event = (ChannelEvent) evt;</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">                if (event.getMsg() instanceof InetSocketAddress) {</span>
<span class="fc" id="L152">                    final InetSocketAddress address = (InetSocketAddress) event</span>
<span class="fc" id="L153">                            .getMsg();</span>
<span class="fc" id="L154">                    outgoingConnectionHandler.removeConnectionClient(address);</span>
                }
            }
<span class="nc" id="L157">        } catch (final Exception e) {</span>
<span class="nc" id="L158">            LOG.error(e.getMessage());</span>
<span class="nc" id="L159">            e.printStackTrace();</span>
<span class="fc" id="L160">        }</span>
<span class="fc" id="L161">    }</span>

    @Override
    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (msg instanceof TPDU) {</span>

<span class="fc" id="L167">            final TPDU tpdu = (TPDU) msg;</span>

            // TODO, next line is stop and fail
<span class="fc" id="L170">            transportBindingService.onIndication(tpdu,</span>
<span class="fc" id="L171">                    ctx.channel().remoteAddress());</span>
        }
<span class="fc" id="L173">    }</span>

    @Override
    public void exceptionCaught(final ChannelHandlerContext ctx,
            final Throwable cause) {
        // handleException(cause, null, null);

        // new ExceptionManager().manageException(cause, null, null, this);
<span class="nc" id="L181">    }</span>

    /*
     * private void handleError(ErrorClass errorClass, ErrorCode errorCode, TPDU
     * msg, ConfirmedRequest request, Unsigned8 invokeId, ChannelHandlerContext
     * ctx) throws Exception {
     *
     * BACnetEID dest = msg.getSourceEID(); BACnetEID src =
     * msg.getDestinationEID();
     *
     * byte serviceId = ((ConfirmedRequest)
     * request).getServiceRequest().getChoiceId(); BACnetErrorAck errorACK = new
     * BACnetErrorAck(errorClass, errorCode, serviceId); ByteQueue bqService =
     * new ByteQueue(); errorACK.write(bqService);
     *
     * TPDU tpdu = new TPDU(src, dest, bqService); URI destUri =
     * DirectoryService.getInstance().resolve(dest); T_UnitDataRequest
     * t_unitDataRequest = new T_UnitDataRequest(destUri, tpdu, 1, false, null);
     * this.doRequest(t_unitDataRequest); }
     */
    /*
     * private ASDU getServiceFromBody(byte[] body) { ByteQueue queue = new
     * ByteQueue(body); ServicesSupported servicesSupported = new
     * ServicesSupported(); servicesSupported.setAll(true);
     * IncomingRequestParser parser = new
     * IncomingRequestParser(servicesSupported, queue); ASDU request = null;
     *
     * try { request = parser.parse(); } catch (BACnetException e) {
     *
     * LOG.debug(e.toString()); throw new
     * TransactionManagerExcpetion(e.getMessage()); } return request; }
     */

    // public boolean isInitialized() {
    // return isInitialized;
    // }

    @Override
    public IncomingConnectionHandler getServerChannel() {
<span class="nc" id="L220">        return this.incomingConnectionHandler;</span>
    }

    public OutgoingConnectionHandler getClientChannel() {
<span class="nc" id="L224">        return this.outgoingConnectionHandler;</span>
    }

    public void waitUntilClosed() {
<span class="nc" id="L228">        incomingConnectionHandler.waitUntilClosed();</span>
<span class="nc" id="L229">    }</span>

    /***********************************************************************
     * Implementation interface ASEService
     ***********************************************************************/

    @Override
    public void doCancel(final BACnetEID destination, final BACnetEID source) {
<span class="nc" id="L237">    }</span>

    @Override
    public synchronized void doRequest(
            final T_UnitDataRequest t_unitDataRequest) {

<span class="fc" id="L243">        LOG.debug(&quot;T_UnitData destination: &quot;</span>
<span class="fc" id="L244">                + t_unitDataRequest.getDestinationAddress());</span>
<span class="fc" id="L245">        outgoingConnectionHandler</span>
<span class="fc" id="L246">                .connect(t_unitDataRequest.getDestinationAddress());</span>
<span class="fc" id="L247">        outgoingConnectionHandler.writeAndFlush(t_unitDataRequest.getData());</span>
<span class="fc" id="L248">    }</span>

    @Override
    public void setTransportBindingService(
            final TransportBindingService transportBindingService) {
<span class="fc" id="L253">        this.transportBindingService = transportBindingService;</span>
<span class="fc" id="L254">    }</span>

    /***********************************************************************
     * Implementation interface BindingConfiguration
     ***********************************************************************/

    @Override
    public void initializeAndStart(final ConnectionFactory connectionFactory) {
        // Check if at least one protocol is set

        // Use the same EventLoopGroup for all EventLoop
<span class="fc" id="L265">        final EventLoopGroup group = new NioEventLoopGroup();</span>

<span class="fc" id="L267">        outgoingConnectionHandler = new OutgoingConnectionHandler(group,</span>
                connectionFactory);
<span class="fc" id="L269">        outgoingConnectionHandler.setLogging(false); // TODO move this somewhere</span>
                                                     // convenient
<span class="fc" id="L271">        outgoingConnectionHandler.initialize(this);</span>

<span class="fc" id="L273">        incomingConnectionHandler = new IncomingConnectionHandler(group,</span>
                connectionFactory);
<span class="fc" id="L275">        incomingConnectionHandler.setLogging(false); // TODO move this somewhere</span>
                                                     // convenient
<span class="fc" id="L277">        incomingConnectionHandler.initialize(this);</span>

<span class="fc" id="L279">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * ch.fhnw.bacnetit.transportbinding.api.BindingConfiguration#shutdown()
     */
    @Override
    public void shutdown() {
<span class="fc" id="L289">        this.incomingConnectionHandler.shutdown();</span>

<span class="fc" id="L291">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>